<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenSSL WASM JS - TLS Client Example</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
    }
    h1, h2 {
      color: #333;
    }
    h1 {
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      max-height: 300px;
      overflow-y: auto;
    }
    button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 4px;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    input, textarea, select {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .result {
      margin-top: 20px;
      padding: 10px;
      background-color: #e8f5e9;
      border-radius: 4px;
    }
    .error {
      color: #d32f2f;
      background-color: #ffebee;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      display: none;
    }
    .info {
      color: #1976d2;
      background-color: #e3f2fd;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    .note {
      font-size: 0.9em;
      color: #666;
      font-style: italic;
    }
    .connection-status {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 5px;
      background-color: #ccc;
    }
    .connection-status.connected {
      background-color: #4CAF50;
    }
    .connection-status.connecting {
      background-color: #FFC107;
      animation: blink 1s infinite;
    }
    .connection-status.error {
      background-color: #F44336;
    }
    @keyframes blink {
      0% { opacity: 0.5; }
      50% { opacity: 1; }
      100% { opacity: 0.5; }
    }
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-bottom: 1px solid #eee;
    }
    .log-entry.info {
      color: #1976d2;
      background-color: transparent;
      padding: 0;
      margin: 5px 0;
    }
    .log-entry.error {
      color: #d32f2f;
      background-color: transparent;
      padding: 0;
      margin: 5px 0;
      display: block;
    }
    .log-entry.success {
      color: #388e3c;
    }
    .log-entry .timestamp {
      color: #666;
      font-size: 0.8em;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <h1>OpenSSL WASM JS - TLS Client Example</h1>
  
  <div class="info">
    <p><strong>Note:</strong> This is a demonstration of how a TLS client could be implemented using OpenSSL-WASM-JS. 
    Due to browser security restrictions, direct TCP socket connections are not possible from JavaScript. 
    This example simulates a TLS connection using a WebSocket proxy.</p>
  </div>
  
  <div>
    <h2>TLS Client Configuration</h2>
    
    <div>
      <label for="serverAddress">Server Address:</label>
      <input type="text" id="serverAddress" value="example.com" placeholder="e.g., example.com">
    </div>
    
    <div>
      <label for="serverPort">Server Port:</label>
      <input type="number" id="serverPort" value="443" min="1" max="65535">
    </div>
    
    <div>
      <label for="tlsVersion">TLS Version:</label>
      <select id="tlsVersion">
        <option value="TLS1.2">TLS 1.2</option>
        <option value="TLS1.3" selected>TLS 1.3</option>
      </select>
    </div>
    
    <div>
      <label for="cipherSuites">Cipher Suites:</label>
      <select id="cipherSuites">
        <option value="HIGH" selected>HIGH (Strong ciphers)</option>
        <option value="MEDIUM">MEDIUM (Medium strength ciphers)</option>
        <option value="DEFAULT">DEFAULT (OpenSSL default ciphers)</option>
        <option value="ALL">ALL (All available ciphers)</option>
      </select>
    </div>
    
    <div>
      <label for="verifyPeer">Verify Server Certificate:</label>
      <input type="checkbox" id="verifyPeer" checked>
    </div>
    
    <button id="connectButton">Connect</button>
    <button id="disconnectButton" disabled>Disconnect</button>
    
    <div class="error" id="connectionError"></div>
  </div>
  
  <div class="result">
    <h3>
      <span class="connection-status" id="connectionStatus"></span>
      Connection Status: <span id="statusText">Disconnected</span>
    </h3>
    
    <div>
      <h4>Connection Log:</h4>
      <pre id="connectionLog"></pre>
    </div>
    
    <div>
      <h4>Send Data:</h4>
      <textarea id="sendData" rows="4" placeholder="Enter data to send (e.g., HTTP request)">GET / HTTP/1.1
Host: example.com
Connection: close

</textarea>
      <button id="sendButton" disabled>Send</button>
    </div>
    
    <div>
      <h4>Received Data:</h4>
      <pre id="receivedData"></pre>
    </div>
    
    <div>
      <h4>Server Certificate:</h4>
      <pre id="serverCertificate">Not connected</pre>
    </div>
  </div>

  <script src="../dist/openssl.min.js"></script>
  <script>
    // Global variables
    let openssl;
    let connected = false;
    let connectionId = null;
    
    // Initialize OpenSSL WASM
    async function init() {
      try {
        openssl = await OpenSSLWasmJS.initialize();
        console.log('OpenSSL version:', openssl.version());
        logMessage('OpenSSL initialized: ' + openssl.version(), 'info');
      } catch (error) {
        console.error('Failed to initialize OpenSSL WASM:', error);
        showError('Failed to initialize OpenSSL WASM: ' + error.message);
      }
    }
    
    // Show error message
    function showError(message) {
      const errorElement = document.getElementById('connectionError');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }
    
    // Hide error message
    function hideError() {
      document.getElementById('connectionError').style.display = 'none';
    }
    
    // Log a message to the connection log
    function logMessage(message, type = 'info') {
      const logElement = document.getElementById('connectionLog');
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'timestamp';
      timestampSpan.textContent = `[${timestamp}]`;
      
      logEntry.appendChild(timestampSpan);
      logEntry.appendChild(document.createTextNode(' ' + message));
      
      logElement.appendChild(logEntry);
      logElement.scrollTop = logElement.scrollHeight;
    }
    
    // Update connection status
    function updateConnectionStatus(status) {
      const statusElement = document.getElementById('statusText');
      const statusIndicator = document.getElementById('connectionStatus');
      
      statusElement.textContent = status;
      
      // Update the status indicator
      statusIndicator.className = 'connection-status';
      if (status === 'Connected') {
        statusIndicator.classList.add('connected');
        connected = true;
      } else if (status === 'Connecting...') {
        statusIndicator.classList.add('connecting');
        connected = false;
      } else if (status.includes('Error')) {
        statusIndicator.classList.add('error');
        connected = false;
      } else {
        connected = false;
      }
      
      // Update button states
      document.getElementById('connectButton').disabled = connected;
      document.getElementById('disconnectButton').disabled = !connected;
      document.getElementById('sendButton').disabled = !connected;
    }
    
    // Connect to the server
    async function connect() {
      if (!openssl) {
        showError('OpenSSL WASM is not initialized yet. Please wait and try again.');
        return;
      }
      
      hideError();
      updateConnectionStatus('Connecting...');
      
      const serverAddress = document.getElementById('serverAddress').value;
      const serverPort = parseInt(document.getElementById('serverPort').value);
      const tlsVersion = document.getElementById('tlsVersion').value;
      const cipherSuites = document.getElementById('cipherSuites').value;
      const verifyPeer = document.getElementById('verifyPeer').checked;
      
      if (!serverAddress) {
        showError('Please enter a server address.');
        updateConnectionStatus('Error: Invalid server address');
        return;
      }
      
      if (isNaN(serverPort) || serverPort < 1 || serverPort > 65535) {
        showError('Please enter a valid port number (1-65535).');
        updateConnectionStatus('Error: Invalid port number');
        return;
      }
      
      logMessage(`Connecting to ${serverAddress}:${serverPort} using ${tlsVersion}...`);
      
      try {
        // In a real implementation, this would establish a TLS connection
        // For this example, we'll simulate a connection
        
        // Simulate connection delay
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Generate a random connection ID
        connectionId = Math.floor(Math.random() * 1000000);
        
        // Simulate successful connection
        updateConnectionStatus('Connected');
        logMessage(`Connected to ${serverAddress}:${serverPort}`, 'success');
        
        // Simulate certificate information
        const certificateInfo = `-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
-----END CERTIFICATE-----

Subject: CN=ISRG Root X1,O=Internet Security Research Group,C=US
Issuer: CN=ISRG Root X1,O=Internet Security Research Group,C=US
Valid from: Jun 4 11:04:38 2015 GMT
Valid to: Jun 4 11:04:38 2035 GMT
Serial: 82:10:CF:B0:D2:40:E3:59:44:63:E0:BB:63:82:8B:00
Fingerprint: 96:BC:EC:06:26:49:76:F3:74:60:77:9A:CF:28:C5:A7:CF:E8:A3:C0`;
        
        document.getElementById('serverCertificate').textContent = certificateInfo;
        
      } catch (error) {
        console.error('Connection error:', error);
        showError('Connection error: ' + error.message);
        updateConnectionStatus('Error: Connection failed');
        logMessage('Connection failed: ' + error.message, 'error');
      }
    }
    
    // Disconnect from the server
    function disconnect() {
      if (!connected || !connectionId) {
        return;
      }
      
      logMessage('Disconnecting...');
      
      // Simulate disconnection
      setTimeout(() => {
        connectionId = null;
        updateConnectionStatus('Disconnected');
        logMessage('Disconnected', 'info');
        document.getElementById('serverCertificate').textContent = 'Not connected';
        document.getElementById('receivedData').textContent = '';
      }, 500);
    }
    
    // Send data to the server
    async function sendData() {
      if (!connected || !connectionId) {
        showError('Not connected to a server.');
        return;
      }
      
      const data = document.getElementById('sendData').value;
      
      if (!data) {
        showError('Please enter data to send.');
        return;
      }
      
      logMessage(`Sending data (${data.length} bytes)...`);
      
      try {
        // In a real implementation, this would send data over the TLS connection
        // For this example, we'll simulate sending and receiving data
        
        // Simulate sending delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        logMessage('Data sent successfully', 'success');
        
        // Simulate receiving a response
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Generate a mock HTTP response
        const mockResponse = `HTTP/1.1 200 OK
Date: ${new Date().toUTCString()}
Server: ECS (dcb/7F84)
Content-Type: text/html; charset=UTF-8
Cache-Control: max-age=604800
Expires: ${new Date(Date.now() + 604800000).toUTCString()}
Content-Length: 1256

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
    <meta charset="utf-8" />
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
    body {
        background-color: #f0f0f2;
        margin: 0;
        padding: 0;
        font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }
    div {
        width: 600px;
        margin: 5em auto;
        padding: 2em;
        background-color: #fdfdff;
        border-radius: 0.5em;
        box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);
    }
    a:link, a:visited {
        color: #38488f;
        text-decoration: none;
    }
    @media (max-width: 700px) {
        div {
            margin: 0 auto;
            width: auto;
        }
    }
    </style>    
</head>
<body>
<div>
    <h1>Example Domain</h1>
    <p>This domain is for use in illustrative examples in documents. You may use this
    domain in literature without prior coordination or asking for permission.</p>
    <p><a href="https://www.iana.org/domains/example">More information...</a></p>
</div>
</body>
</html>`;
        
        document.getElementById('receivedData').textContent = mockResponse;
        logMessage(`Received response (${mockResponse.length} bytes)`, 'success');
        
      } catch (error) {
        console.error('Error sending data:', error);
        showError('Error sending data: ' + error.message);
        logMessage('Error sending data: ' + error.message, 'error');
      }
    }
    
    // Add event listeners
    document.addEventListener('DOMContentLoaded', () => {
      init();
      
      document.getElementById('connectButton').addEventListener('click', connect);
      document.getElementById('disconnectButton').addEventListener('click', disconnect);
      document.getElementById('sendButton').addEventListener('click', sendData);
    });
  </script>
</body>
</html>
